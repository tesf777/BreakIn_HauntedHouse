
### 问题一：鬼屋内部没有墙壁，设计行动规则，并给出机器人成功到达出口过程的路线

行动规则：

![[Pasted image 20221015203025.png]]

机器人一开始在(1,1)创建，将(1,1)作为元素加入探索集。
我使用了随机函数生成幽灵以及他们的方向为(flag=0，左或者下；flag=1，右或者上)
假设幽灵在(4,1)向上移动,(2,4)向右移动
![[Pasted image 20221015204251.png]]
此时已知机器人邻域为：(1,2),(2,1) 把他们加入前沿队列
经过寒意浓度感知h(1,2)=0,h(2,1)=0
如果前沿队列中有可以行动的寒意浓度，则优先选择他，这里随机选择(2,1)
并将他添加到探索集，并清空前沿队列

-------------------

![[Pasted image 20221015212527.png]]
此时机器人邻域为(已在探索集的不添加)：(2,2),(3,1) 把他们加入前沿队列
经过寒意浓度感知h(2,2)=0,h(3,1)=1
寒意浓度都可以行动，我们仍然随机选择(3,1)
并将他添加到探索集，并清空前沿队列

----

![[Pasted image 20221015213009.png]]
此时机器人邻域为(已在探索集的不添加)：(3,2),(4,1) 把他们加入前沿队列
经过寒意浓度感知h(3,2)=1,h(4,1)=0
寒意浓度都可以行动，我们仍然随机选择(4,1)
并将他添加到探索集，并清空前沿队列

-----

![[Pasted image 20221015213231.png]]
此时机器人邻域为(已在探索集的不添加)：(4,2),(5,1) 把他们加入前沿队列
经过寒意浓度感知h(4,2)=0,h(5,1)=0
寒意浓度都可以行动，我们仍然随机选择(4,2)
并将他添加到探索集，并清空前沿队列

---

![[Pasted image 20221015213358.png]]
此时机器人邻域为(已在探索集的不添加)：(3,2),(4,3),(5,2) 把他们加入前沿队列
经过寒意浓度感知h(3,2)=0,h(5,2)=0,h(4,3)=0
寒意浓度都可以行动，我们仍然随机选择(5,2)
并将他添加到探索集，并清空前沿队列

---

![[Pasted image 20221015213741.png]]
此时机器人邻域为(已在探索集的不添加)：(5,1),(5,3),(6,2) 把他们加入前沿队列
经过寒意浓度感知h(6,2)=0,h(5,1)=0,h(5,3)=2
寒意浓度都可以行动，我们仍然随机选择(6,2) 这里已经存在失败风险了
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015214145.png]]
此时机器人邻域为(已在探索集的不添加)：(5,2),(6,3) 把他们加入前沿队列
经过寒意浓度感知h(6,3)=0,h(5,2)=0
寒意浓度都可以行动，我们仍然随机选择(6,3) 这里会有绕圈子情况，但是一定不会走到重复的路，所以只会失败，而不会死循环
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015214419.png]]
![[Pasted image 20221015214442.png]]
![[Pasted image 20221015214538.png]]
![[Pasted image 20221015214801.png]]

路径：
(2,1)->(3,1)->(4,1)->(4,2)->(5,2)->(6,2)->(6,3)->(6,4)->(6,5)->(6,6)
直到这里，我们很顺利，躲开了绕远路和失败，不过也存在绕着出口兜圈的情况，需要优化

---
### 问题二：鬼屋内部有墙壁，设计行动规则，尽可能快速到达并给出机器人成功到达出口过程的两条路线，评估到达目的地的成功率和平均时间？
![[Pasted image 20221015215629.png]]

我们使用启发式函数的方式，我们设置启发式函数为**曼哈顿距离**

此时已知机器人邻域为：(1,2),(2,1) 把他们加入前沿队列
经过寒意浓度感知h(1,2)=0,h(2,1)=0
前沿队列中有可以行动的寒意浓度，并按照启发式函数最小排序，如果没有就不行动
如果相同就随机选择 曼哈顿距离同为9
这里随机选择(2,1)
并将他添加到探索集，并清空前沿队列


---
![[Pasted image 20221015212527.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(2,2) 
把他们加入前沿队列
经过寒意浓度感知h(2,2)=0
寒意浓度都可以行动，我们选择(2,2)
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015220643.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(1,2),(2,3),(3,2)
把他们加入前沿队列
经过寒意浓度感知h(1,2)=0,h(2,3)=0,h(3,2)=1
寒意浓度都可以行动，曼哈顿距离后两个比较小，我们选择(2,3)
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015221029.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(1,3),(3,3)
把他们加入前沿队列
经过寒意浓度感知h(1,3)=0,h(3,3)=1
寒意浓度都可以行动，曼哈顿距离后一个比较小，我们选择(3,3)
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015221200.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(4,3)
把他们加入前沿队列
经过寒意浓度感知h(4,3)=0
寒意浓度都可以行动，曼哈顿距离为5，我们选择(4,3)
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015221412.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(4,4)，(5,3)
把他们加入前沿队列
经过寒意浓度感知h(4,4)=2,h(5,3)=2
寒意浓度都可以行动，曼哈顿距离为4，我们选择(5,3)
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015221605.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(6,3)，(5,2)
把他们加入前沿队列
经过寒意浓度感知h(6,3)=0,h(5,2)=0
寒意浓度都可以行动，前者曼哈顿距离为3，我们选择(6,3)
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015221820.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(6,4)，(6,2)
把他们加入前沿队列
经过寒意浓度感知h(6,4)=0,h(6,2)=0
寒意浓度都可以行动，前者曼哈顿距离为2，我们选择(6,4)
并将他添加到探索集，并清空前沿队列

---
此后与问题一情况一样，在启发式函数的引导下，路径更加清晰同时，不会走弯路了
路线：
(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(5,3)->(6,3)->(6,4)->(6,5)->(6,6)



---
另一条分析方法与这一条相似
从这里开始
![[Pasted image 20221015220643.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(1,2),(2,3),(3,2)
把他们加入前沿队列
经过寒意浓度感知h(1,2)=0,h(2,3)=0,h(3,2)=1
寒意浓度都可以行动，曼哈顿距离后两个比较小，我们选择(3,2)
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015223057.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(3,1),(4,2)
把他们加入前沿队列
经过寒意浓度感知h(3,1)=0,h(4,2)=0
寒意浓度都可以行动，曼哈顿距离后一个比较小，我们选择(4,2)
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015223242.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(4,3),(4,1)
把他们加入前沿队列
经过寒意浓度感知h(4,3)=0,h(4,1)=0
寒意浓度都可以行动，曼哈顿距离前一个比较小，我们选择(4,3)
并将他添加到探索集，并清空前沿队列

---
![[Pasted image 20221015223421.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(4,4),(5,3)
把他们加入前沿队列
经过寒意浓度感知h(5,3)=2,h(4,4)=2
寒意浓度都可以行动，曼哈顿距离都为4，我们选择(4,4)就会失败，这里我们选择(5,3)
虽然是上帝视角，但是也侧面印证了我们对寒意浓度的设定上有小问题，如果需要提高成功率，可以尝试改变行动规则
并将他添加到探索集，并清空前沿队列

----
![[Pasted image 20221015223855.png]]
此时机器人邻域为(已在探索集的不添加,被墙挡住的不添加)：(6,3),(5,2)
把他们加入前沿队列
经过寒意浓度感知h(6,3)=0,h(5,2)=0
寒意浓度都可以行动，曼哈顿距离前一个比较小，我们选择(6,3)
并将他添加到探索集，并清空前沿队列

---
此后与上一条路线一样
(1,2)->(2,2)->(3,2)->(4,2)->(4,3)->(5,3)->(6,3)->(6,4)->(6,5)->(6,6)

#### 评估
**至此两条路线走完，可以说算法上并不复杂，在两次路径模拟中，我们发现寒意浓度几乎没有影响路径的行动，所以需要重新设置行动基准，例如我演示的第二条路线的关键一步，如果机器人可以在(4,4)及时停止，就可以绕过幽灵到达终点，提高成功率(虽然绕了远路)**

**测试的几条线路，成功的路线几乎都走了下半条路，10步到达了终点。
当然，这是幽灵被随机到我指定的位置而得到的情况，正常情况下，会有更多线路**

我推测成功率应该在50%之上，平均步数应该在11步左右(因为启发式函数的指引，很难有绕远路的情况发生，上半条路比较远，需要12步左右，下半条不出意外的话10步即可)

预测好了 
**对寒冷值为<=3行动的行为规则 进行了1000次模拟，成功率大概在53%左右，通过半数，并且方差相对比较大**
**对寒冷值为<=2行动的行为规则 进行了1000次模拟，成功率也接近53%，同样通过半数，方差相对较小，二者没有特别巨大的差距
![[Pasted image 20221020174743.png]]
这里我选择了前者，因为我认为机器人更冒险的行动会更快到达终点，在成功率相近的前提下要更快。**

---

### 问题三：假设机器人预先知道所有墙壁位置以及幽灵初始位置和初始方向，请设计一个搜索算法找到最快路径？

![[Pasted image 20221015230017.png]]
最短路径已经很明显了，根据曼哈顿距离，最短距离就为10步。
最快路径就需要考虑幽灵的位置。
红线到达从纵向“幽灵走廊”需要5步，蓝线到达纵向“幽灵走廊”需要4步，我们已知幽灵的出发路线和方向之后，就可以尽可能选择这两条路，因为可以等待，所以绕远路反而不划算。
**我们先考虑纵向幽灵的出现位置和方向，对路径选择的影响而暂时不管横向幽灵**
![[Pasted image 20221015231002.png]]
上图是幽灵朝下运动会和蓝线相遇的情况
![[Pasted image 20221016092200.png]]
上图是幽灵向上运动与蓝线相遇的情况
![[Pasted image 20221016092404.png]]
在这个位置生成的幽灵如果向上向下都会与红线相遇，很神奇的是他们都在同一个位置

---
![[Pasted image 20221016091143.png]]
横向行动的幽灵如果要接触两根线，只能生成在如图(4,4)位置向左移动
因此 如果想让机器人走这两条路线，随机到的幽灵位置方向应该不在上述位置方向
反之，如果满足就都能通过这两条线通过 
(横向移动不生成在(4,4)向左)∧(纵向移动不生成在(4,4)与(4,6)∨纵向移动不生成在(4,4))

我们进一步处理通过不了的情况：
所有红线无法通过的情况化简得到：(1)∨(2)
**1）(4,4)向左
2)(4,4)向上和下


所有蓝线无法通过的情况化简得到：(1)∨(2)∨(3)
**1）(4,4)向左
2)(4,4)向上和下
3)(4,6)向上和下

所有红蓝线无法通过的情况化简得到：(1)∨(2)
**1）(4,4)向左
2)(4,4)向上和下**

所以机器人行动规则应该为：
一开始检测两个幽灵位置：
如果横向幽灵在(4,4)向左或者纵向幽灵在(4,4)：停止一回合
如果纵向幽灵在(4,6):选择红线
否则选择蓝线或者红线都能到达终点




---
#### 然而上面好像不算搜索算法，只能算人为路径规划
或者还有一种思路：
在启发式函数仍然为曼哈顿路径的前提下，
为机器人增加一个预测函数：
行动逻辑伪代码如下：
>> 把前沿队列按照曼哈顿距离升序，弹出第一个
>> 如果第一个的坐标是幽灵行动的下一个坐标，就停止一轮行动
>> 清空前沿队列

根据第二问我们的效果来看，启发式函数可以自发带领机器人选择蓝线或者红线，
所以不需要人为规划，我们只需要在合适的地方不行动，躲开幽灵即可。

**这样就可以在保证安全的前提下快速到达终点，距离为10步，使用了11个回合到达
路线可能为红线或者蓝线**
具体可以在代码中见到 图像和探索过程